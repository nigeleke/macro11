      1         000001                  debug=1
      1                                 	.title	at.sml	-   assembler/translator system macros
      2                                 	; @(#)at.sml	1.3 11/3/82
      3
      4                                 	.ident	/10may4/
      5
      6                                 	.macro	always		;all files of macro
      7
      8                                 	.macro	.data
      9                                 	entsec	.data
     10                                 	.endm	.data
     11
     12                                 	.macro	.text
     13                                 	entsec	.text
     14                                 	.endm
     15
     16                                 	.macro	.bss
     17                                 	entsec	.bss
     18                                 	.endm
     19
     20                                 mk.symbol=1			;one to make symbols, 0 otherwise
     21                                 x40=	0
     22                                 pdpv45=	0			; host machine has 'mul', 'div', sob' instrucs.
     23                                 				; if not you will have to write macros for them
     24                                 $timdf=	7			; California Time Zone
     25                                 				; should really use ftime(2) for this and for
     26                                 				; DST.
     27                                 ;xfltg=	0		;define to assmbl out floating hardware
     28                                 rsx11d	=	0	; rsx11d features
     29                                 debug	=	0	; <<< REEDS if non zero includes debug junk
     30
     31                                 ft.id=	1			;have set i & d.  set =0 if not
     32
     33                                 ft.unx = 1			; this macro-11 is for UNIX.  =0 if not.
     34
     35                                 	.nlist	bex
     36
     37                                 tab=	11
     38                                 lf=	12
     39                                 vt=	13
     40                                 ff=	14
     41                                 cr=	15
     42                                 space=	40
     43
     44                                 bpmb	=	20		;bytes per macro block
     45
     46
     47
     48
     49
     50                                 	.psect	.text	con, shr, gbl,ins
     51                                 	.psect	.data	con, dat, prv, gbl
     52                                 	.psect	.bss	con, bss, gbl
     53
     54                                 	.psect	dpure	con, dat, prv, gbl
     55                                 	.psect	mixed	con, prv, gbl
     56                                 	.psect	errmes	con, dat, prv, gbl
     57                                 	.psect	impure	con, bss, gbl
     58                                 	.psect	imppas	con, bss, gbl
     59                                 	.psect	implin	con, bss, gbl
     60                                 	.psect	swtsec	con, dat, prv, gbl	; unix command line flags
     61                                 	.psect	cndsec 	con, dat, prv, gbl	; gt, le, equ, etc.  for '.if'
     62                                 	.psect	crfsec 	con, dat, prv, gbl	; args for -cr flag
     63                                 	.psect	edtsec 	con, dat, prv, gbl	; args for .enabl
     64                                 	.psect	lctsec 	con, dat, prv, gbl	; args for .list
     65                                 	.psect	psasec 	con, dat, prv, gbl
     66                                 	.psect	pstsec 	con, dat, prv, gbl
     67                                 	.psect	rolbas 	con, dat, prv, gbl	; core allocation: starts of tables
     68                                 	.psect	rolsiz 	con, dat, prv, gbl	; sizes of table entries
     69                                 	.psect	roltop 	con, dat, prv, gbl	; tops of tables
     70                                 	.psect	xpcor	con,bss	, gbl	; this one MUST come last in core
     71
     72


     73                                 	.macro	entsec	name 	;init a section
     74                                 	.psect	name	con
     75                                 	.endm	entsec
     76
     77
     78
     79                                 	.macro jeq	x,?fred
     80                                 	bne	fred
     81                                 	jmp	x
     82                                 fred:
     83                                 	.endm
     84                                 	.macro	jne	x,?fred
     85                                 	beq	fred
     86                                 	jmp	x
     87                                 fred:
     88                                 	.endm
     89                                 	.macro	xitsec
     90                                 	entsec	.text
     91                                 	.endm	xitsec
     92
     93
     94                                 	.macro	call	address
     95                                 	jsr	pc,address
     96                                 	.endm
     97
     98                                 	.macro	return
     99                                 	rts	pc
    100                                 	.endm
    101
    102
    103                                 	.macro	always
    104                                 	.nlist	bex
    105                                 	.endm	always
    106                                 	.endm	always
    107
    108
    109         000001=                 	.if ne debug
    110
    111                                 	.macro	ndebug n
    112                                 	.globl	ndebug,..z
    113                                 	mov	n,..z
    114                                 	call	ndebug
    115                                 	.endm
    116
    117                                 	.macro	sdebug	string
    118                                 	.globl	sdebug,..z,..zbuf
    119                                 	x = 0
    120                                 	.irpc	t,<string>
    121                                 	movb	#''t,..zbuf+x
    122                                 	x = x+1
    123                                 	.endm
    124                                 	movb	#0,..zbuf+x
    125                                 	mov	#..zbuf,..z
    126                                 	call	sdebug
    127                                 	.endm
    128
    129              0=                 	.iff
    130
    131                                 	.macro	ndebug n
    132                                 	.endm
    133
    134                                 	.macro	sdebug	string
    135                                 	.endm
    136
    137                                 	.endc
    138
    139
    140                                 	.macro	param	mne,	value	;define default parameters
    141                                 	.iif ndf mne,	mne=	value
    142                                 	.list
    143                                 mne=	mne
    144                                 	.nlist
    145                                 	.endm


    146                                 	.macro	putkb	addr	;list to kb
    147                                 	.globl	putkb
    148                                 	mov	addr,r0
    149                                 	call	putkb
    150                                 	.endm
    151
    152                                 	.macro	putlp	addr	;list to lp
    153                                 	.globl	putlp
    154                                 	mov	addr,r0
    155                                 	call	putlp
    156                                 	.endm
    157
    158                                 	.macro	putkbl	addr	;list to kb and lp
    159                                 	.globl	putkbl
    160                                 	mov	addr,r0
    161                                 	call	putkbl
    162                                 	.endm
    163
    164
    165                                 	.macro	xmit	wrdcnt	;move small # of words
    166                                 	.globl	xmit0
    167                                 	call	xmit0-<wrdcnt*2>
    168                                 	.endm	xmit
    169
    170
    171                                 ;the macro "genswt" is used to specify  a command
    172                                 ;string switch (1st argument) and the address of
    173                                 ;the routine to be called when encountered (2nd arg).
    174                                 ; the switch is made upper-case.
    175
    176                                 	.macro	genswt	mne,addr,?label
    177                                 	entsec	swtsec
    178                                 label:	.irpc	x,mne
    179                                 	.if ge ''x-141
    180                                 		.if le ''x-172
    181                                 			.byte ''x-40
    182                                 		.iff
    183                                 			.byte ''x
    184                                 		.endc
    185                                 	.iff
    186                                 	.byte ''x
    187                                 	.endc
    188                                 	.endm
    189                                 	.iif ne <.-label&1>,	.byte	0
    190                                 	.word	addr
    191                                 	xitsec
    192                                 	.endm


    193                                 	.macro	zread	chan
    194                                 	.globl	zread
    195                                 	mov	#chan'chn,r0
    196                                 	call	zread
    197                                 	.endm	zread
    198
    199                                 	.macro	zwrite	chan
    200                                 	.globl	zwrite
    201                                 	mov	#chan'chn,r0
    202                                 	call	zwrite
    203                                 	.endm	zwrite


    204                                 	.macro	genedt	mne,subr	;gen enable/disable table
    205                                 	entsec	edtsec
    206                                 	.rad50	/mne/
    207                                 	.if nb	subr
    208                                 	.word	subr
    209                                 	.iff
    210                                 	.word	cpopj
    211                                 	.endc
    212                                 	.word	ed.'mne
    213                                 	xitsec
    214                                 	.endm	genedt
    215
    216
    217                                 ;the macro "gencnd" is used to specify conditional
    218                                 ;arguments.  it takes two or three arguments:
    219
    220                                 ;	1-	mnemonic
    221                                 ;	2-	subroutine to be called
    222                                 ;	3-	if non-blank, complement condition
    223
    224                                 	.macro	gencnd	mne,subr,toggle	;generate conditional
    225                                 	entsec	cndsec
    226                                 	.rad50	/mne/
    227                                 	.if b	<toggle>
    228                                 	.word	subr
    229                                 	.iff
    230                                 	.word	subr+1
    231                                 	.endc
    232                                 	xitsec
    233                                 	.endm


    234                                 	.macro	ch.mne
    235
    236                                 ch.ior=	'!
    237                                 ch.qtm=	'"
    238                                 ch.hsh=	'#
    239                                 ch.dol=	'$
    240                                 ch.pct=	'%
    241                                 ch.and=	'&
    242                                 ch.xcl=	''
    243
    244                                 ch.lp=	'(
    245                                 ch.rp=	')
    246                                 ch.mul=	'*
    247                                 ch.add=	'+
    248                                 ch.com=	',
    249                                 ch.sub=	'-
    250                                 ch.dot=	'.
    251                                 ch.div=	'/
    252
    253                                 ch.col=	':
    254                                 ch.smc=	';
    255                                 ch.lab=	'<
    256                                 ch.equ=	'=
    257                                 ch.rab=	'>
    258                                 ch.qm=	'?
    259
    260                                 ch.ind=	'@
    261                                 ch.bsl=	'\
    262                                 ch.uar=	'^
    263
    264                                 let.a=	'a&^c40
    265                                 let.b=	'b&^c40
    266                                 let.c=	'c&^c40
    267                                 let.d=	'd&^c40
    268                                 let.e=	'e&^c40
    269                                 let.f=	'f&^c40
    270                                 let.g=	'g&^c40
    271                                 let.o=	'o&^c40
    272                                 let.p=	'p&^c40
    273                                 let.r=	'r&^c40
    274                                 let.z=	'z&^c40
    275
    276                                 dig.0=	'0
    277                                 dig.9=	'9
    278                                 	.macro	ch.mne
    279                                 	.endm	ch.mne
    280                                 	.endm	ch.mne
    281
    282                                 	.macro error num,arg, mess ,?x
    283                                 	sdebug	<num>
    284                                 	.globl	err.'arg,ern'num, errbts,errref
    285                                 	.if	b	<mess>
    286                                 	deliberate error mistake
    287                                 	.endc
    288                                 	.if	dif	0,num
    289                                 	.globl	err.xx
    290                                 	tst	err.xx
    291                                 	bne	x
    292                                 	mov	#ern'num,err.xx
    293                                 x:
    294                                 	.endc
    295                                 	bis	#err.'arg,errbts
    296                                 	.endm
    297
    298
    299
    300                                 	.macro	setnz	addr	;set addr to non-zero for t/f flags
    301                                 	mov	sp,addr
    302                                 	.endm
    303
    304
    305                                 	.macro	bisbic	arg	; used by .list/.nlist, .enabl/.dsabl
    306                                 	.globl	bisbic
    307                                 	mov	#arg,-(sp)
    308                                 	call	bisbic
    309                                 	tst	(sp)+
    310                                 	.endm


    311                                 				;roll handler calls
    312
    313                                 	.macro	search	rolnum	;binary search
    314                                 	mov	#rolnum,r0
    315                                 	.globl	search
    316                                 	call	search
    317                                 	.endm
    318
    319                                 	.macro	scan	rolnum	;linear scan
    320                                 	mov	#rolnum,r0
    321                                 	.globl	scan
    322                                 	call	scan
    323                                 	.endm
    324
    325                                 	.macro	scanw	rolnum	;linear scan, one word
    326                                 	mov	#rolnum,r0
    327                                 	.globl	scanw
    328                                 	call	scanw
    329                                 	.endm
    330
    331                                 	.macro	next	rolnum	;fetch next entry
    332                                 	mov	#rolnum,r0
    333                                 	.globl	next
    334                                 	call	next
    335                                 	.endm
    336
    337                                 	.macro	append	rolnum	;append to end of roll
    338                                 	mov	#rolnum,r0
    339                                 	.globl	append
    340                                 	call	append
    341                                 	.endm
    342
    343                                 	.macro	zap	rolnum	;clear roll
    344                                 	mov	#rolnum,r0
    345                                 	.globl	zap
    346                                 	call	zap
    347                                 	.endm
    348
    349                                 ;	call	insert		;insert (must be preceded by one
    350                                 				;of the above to set pointers)
    351                                 ;	call	setrol		;save and set regs for above


    352                                 ;flags used in symbol table mode
    353
    354                                 	.macro	st.flg
    355
    356                                 .if le ft.unx
    357
    358                                 ovrflg=	000004		;overlay (psect only)
    359                                 defflg=	000010		;defined
    360                                 relflg=	000040		;relocatable
    361                                 glbflg=	000100		;global
    362                                 dfgflg= 000200		; default global <rsx11d>... reeds's guess
    363
    364
    365                                 .endc
    366
    367                                 .if gt ft.unx
    368
    369                                 			; ****** these should not be changed!! ******
    370                                 shrflg=	000001		;shareable (psect only)
    371                                 .if gt ft.id
    372                                 insflg=	shrflg*2	;instruction space (psect only)
    373                                 bssflg=	insflg*2	;blank section (psect only)
    374                                 m.idf=	shrflg!insflg!bssflg	;mask to turn them off
    375                                 .iff
    376                                 bssflg=	shrflg*2
    377                                 m.idf=	shrflg!bssflg
    378                                 .endc
    379                                 b.idf=	1		;shift count to make above bits word offset
    380                                 			; ***********************************
    381                                 defflg=	000010		;defined
    382                                 ovrflg=	000020		;overlay (psect only)
    383                                 relflg=	000040		;relocatable
    384                                 glbflg=	000100		;global
    385                                 dfgflg= 000200		; default global <rsx11d>... reeds's guess
    386
    387                                 .endc
    388
    389                                 ;
    390                                 ; default psect attribs.
    391                                 ; can be changed, but make sure all customers know about
    392                                 ; it, including all the linkers.
    393                                 ;
    394                                 pattrs=relflg!defflg		; For .psects and blank .csects
    395                                 aattrs=glbflg!defflg!ovrflg		; For .asect
    396                                 cattrs=glbflg!relflg!defflg!ovrflg	; For named .csects
    397
    398                                 regflg=	000001		;register
    399                                 lblflg=	000002		;label
    400                                 mdfflg=	000004		;multilpy defined
    401                                 	.macro	st.flg
    402                                 	.endm
    403                                 	.endm	st.flg
    404
    405
    406
    407                                 	.macro	ct.mne
    408                                 	.globl	cttbl
    409                                 ct.eol	=	000		; eol
    410                                 ct.com	=	001		; comma
    411                                 ct.tab	=	002		; tab
    412                                 ct.sp	=	004		; space
    413                                 ct.pcx	=	010		; printing character
    414                                 ct.num	=	020		; numeric
    415                                 ct.alp	=	040		; alpha, dot, dollar
    416                                 ct.lc	=	100		; lower case alpha
    417                                 ct.smc	=	200		; semi-colon (sign bit)
    418
    419                                 ct.pc	=	ct.com!ct.smc!ct.pcx!ct.num!ct.alp
    420                                 	.macro	ct.mne
    421                                 	.endm	ct.mne
    422                                 	.endm	ct.mne
    423
    424
    425         000001                  	.end


      1                                 	.title	srch
      2                                 	.ident	/03apr4/
      3
      4                                 	.mcall	(at)always,scan,genedt
      5                                 	.mcall (at)sdebug,ndebug
      6 000000                          	always
      1
      2                                 	.macro	.data
      3                                 	entsec	.data
      4                                 	.endm	.data
      5
      6                                 	.macro	.text
      7                                 	entsec	.text
      8                                 	.endm
      9
     10                                 	.macro	.bss
     11                                 	entsec	.bss
     12                                 	.endm
     13
     14         000001                  mk.symbol=1			;one to make symbols, 0 otherwise
     15         000000                  x40=	0
     16         000000                  pdpv45=	0			; host machine has 'mul', 'div', sob' instrucs.
     17                                 				; if not you will have to write macros for them
     18         000007                  $timdf=	7			; California Time Zone
     19                                 				; should really use ftime(2) for this and for
     20                                 				; DST.
     21                                 ;xfltg=	0		;define to assmbl out floating hardware
     22         000000                  rsx11d	=	0	; rsx11d features
     23         000000                  debug	=	0	; <<< REEDS if non zero includes debug junk
     24
     25         000001                  ft.id=	1			;have set i & d.  set =0 if not
     26
     27         000001                  ft.unx = 1			; this macro-11 is for UNIX.  =0 if not.
     28
     29                                 	.nlist	bex
     30
     31         000011                  tab=	11
     32         000012                  lf=	12
     33         000013                  vt=	13
     34         000014                  ff=	14
     35         000015                  cr=	15
     36         000040                  space=	40
     37
     38         000020                  bpmb	=	20		;bytes per macro block
     39
     40
     41
     42
     43
     44 000000     002                  	.psect	.text	con, shr, gbl,ins
     45 000000     003                  	.psect	.data	con, dat, prv, gbl
     46 000000     004                  	.psect	.bss	con, bss, gbl
     47
     48 000000     005                  	.psect	dpure	con, dat, prv, gbl
     49 000000     006                  	.psect	mixed	con, prv, gbl
     50 000000     007                  	.psect	errmes	con, dat, prv, gbl
     51 000000     010                  	.psect	impure	con, bss, gbl
     52 000000     011                  	.psect	imppas	con, bss, gbl
     53 000000     012                  	.psect	implin	con, bss, gbl
     54 000000     013                  	.psect	swtsec	con, dat, prv, gbl	; unix command line flags
     55 000000     014                  	.psect	cndsec 	con, dat, prv, gbl	; gt, le, equ, etc.  for '.if'
     56 000000     015                  	.psect	crfsec 	con, dat, prv, gbl	; args for -cr flag
     57 000000     016                  	.psect	edtsec 	con, dat, prv, gbl	; args for .enabl
     58 000000     017                  	.psect	lctsec 	con, dat, prv, gbl	; args for .list
     59 000000     020                  	.psect	psasec 	con, dat, prv, gbl
     60 000000     021                  	.psect	pstsec 	con, dat, prv, gbl
     61 000000     022                  	.psect	rolbas 	con, dat, prv, gbl	; core allocation: starts of tables
     62 000000     023                  	.psect	rolsiz 	con, dat, prv, gbl	; sizes of table entries
     63 000000     024                  	.psect	roltop 	con, dat, prv, gbl	; tops of tables
     64 000000     025                  	.psect	xpcor	con,bss	, gbl	; this one MUST come last in core
     65
     66
     67                                 	.macro	entsec	name 	;init a section
     68                                 	.psect	name	con
     69                                 	.endm	entsec
     70
     71
     72
     73                                 	.macro jeq	x,?fred
     74                                 	bne	fred
     75                                 	jmp	x
     76                                 fred:
     77                                 	.endm
     78                                 	.macro	jne	x,?fred
     79                                 	beq	fred
     80                                 	jmp	x
     81                                 fred:
     82                                 	.endm
     83                                 	.macro	xitsec
     84                                 	entsec	.text
     85                                 	.endm	xitsec
     86
     87
     88                                 	.macro	call	address
     89                                 	jsr	pc,address
     90                                 	.endm
     91
     92                                 	.macro	return
     93                                 	rts	pc
     94                                 	.endm
     95
     96
     97                                 	.macro	always
     98                                 	.nlist	bex
     99                                 	.endm	always
      7
      8                                 	.globl	srchi
      9                                 	.globl	search,	next,	scan,	scanc,	scanw
     10                                 	.globl	append,	insert,	zap
     11                                 	.globl	rolndx,	rolupd,	mactop , symbot
     12
     13                                 	.globl	symovf
     14
     15                                 	.globl	xmit0
     16                                 	.globl	symlp,	symhp,	dumrol
     17                                 	.globl	savreg,	symbol
     18
     19              1=                 	.if df	rsx11d
     20                                 	.globl	ed.reg,	edmask,	symrol,	regrol, cpopj
     21                                 	.endc
     22
     23 000000                          	xitsec			;start in default sector
      1 000000                          	entsec	.text
      1 000000     002                  	.psect	.text	con
     24
     25 000000                          srchi:				;search init
     26 000000  012700  000000G         	mov	#dumrol,r0	;end of variable rolls
     27 000004  016760  000000G 000000' 1$:	mov	symhp,<^pl rolbas>(r0)	;point all to top
     28 000012  016760  000000G 000000' 	mov	symhp,<^pl roltop>(r0)
     29 000020  105060  000001'         	clrb	<^pl rolsiz>+1(r0)
     30 000024  162700  000002          	sub	#2,r0		;get next lower
     31 000030  002365                  	bge	1$
     32 000032  016767  000000G 000012' 	mov	symlp,mactop	;bottom is start of macros
     33 000040  062767  000017  000012' 	add	#bpmb-1,mactop	;must be even
     34 000046  042767  000017  000012' 	bic	#bpmb-1,mactop
     35 000054  016767  000000G 000014' 	mov	symhp,symbot	;for sake of 'uplift' <<< REEDS
     36 000062  016767  000000G 000000G 	mov	symhp,symlp	;symlp should always == symbot [debug, REEDS]
     37 000070                          	return
      1 000070  000207                  	rts	pc


     38              0=                 	.if ndf	rsx11d
     39
     40                                 search:				;binary roll search
     41                                 	call	setrol		;set roll registers
     42                                 	mov	r3,-(sp)
     43                                 	sub	r3,r1		;point one slot low
     44                                 	mov	r2,r3
     45                                 	sub	r1,r3		;compute size
     46                                 	clr	r0		;get set to compute search offset
     47                                 	sec			;  (r0 doubles as t/f flag)
     48                                 1$:	rol	r0		;shift bit
     49                                 	bic	r0,r3		;clear corresponding bit.  last one?
     50                                 	bne	1$		;  no
     51                                 2$:	add	r0,r1
     52                                 3$:	asr	r0		;end of iteration, halve offset
     53                                 	bic	#2,r0		;end?
     54                                 	beq	7$		;  yes
     55                                 4$:	cmp	r2,r1		;off in no-mans's land?
     56                                 	blos	6$		;  yes
     57                                 	cmp	(r4),(r1)	;no, first words match?
     58                                 	bne	5$		;  no
     59                                 	cmp	2(r4),2(r1)	;yes, how about second?
     60                                 	beq	8$		;  yes, found
     61                                 5$:	bhi	2$		;no, branch if too high
     62                                 6$:	sub	r0,r1		;lower index
     63                                 	br	3$
     64
     65                                 7$:	cmp	(r1)+,(r1)+	;point to insertion slot
     66                                 8$:	mov	(sp)+,r3
     67                                 	br	scanx		;exit through scan


     68              1=                 	.iff
     69
     70 000072                          search:
     71 000072                          	call	setrol
      1 000072  004767  001004          	jsr	pc,setrol
     72 000076  032767  000000G 000000G 	bit	#ed.reg,edmask	;register definition enabled?
     73 000104  001017                  	bne	10$		;if ne no
     74 000106  020527  000000G         	cmp	r5,#symrol	;symbol roll?
     75 000112  001014                  	bne	10$		;if ne no
     76 000114  032714  000007          	bit	#7,(r4)		;make ruff ruff test bypass 90%
     77 000120  001011                  	bne	10$		;if ne don't check for register
     78 000122                          	scan	regrol		;scan register roll
      1 000122  012700  000000G         	mov	#regrol,r0
      2                                 	.globl	scan
      3 000126                          	call	scan
      1 000126  004767  000202          	jsr	pc,scan
     79 000132  010567  000004'         	mov	r5,rolndx	;restore roll index
     80 000136  005700                  	tst	r0		;find symbol?
     81 000140  001401                  	beq	10$		;if eq no find em
     82 000142                          	return			;
      1 000142  000207                  	rts	pc
     83 000144  010146                  10$:	mov	r1,-(sp)	;save roll base
     84 000146  020102                  	cmp	r1,r2		;any in roll?
     85 000150  001434                  	beq	5$		;if eq no
     86 000152  160302                  	sub	r3,r2		;calculate high and low bounds
     87 000154  010100                  	mov	r1,r0		;
     88 000156  042716  177770          	bic	#177770,(sp)	;
     89 000162  010001                  1$:	mov	r0,r1		;calculate trial index
     90 000164  060201                  	add	r2,r1		;
     91 000166  006001                  	ror	r1		;halve result
     92 000170  042701  000007          	bic	#7,r1		;clear garbage bits
     93 000174  051601                  	bis	(sp),r1		;
     94 000176  021114                  	cmp	(r1),(r4)	;compare high parts
     95 000200  101014                  	bhi	3$		;if hi set new high limit
     96 000202  103405                  	blo	2$		;if lo set new low limit
     97 000204  026164  000002  000002  	cmp	2(r1),2(r4)	;compare low parts
     98 000212  001414                  	beq	6$		;if eq hit
     99 000214  101006                  	bhi	3$		;if hi set new high limit
    100 000216  010100                  2$:	mov	r1,r0		;set new low limit
    101 000220  060300                  	add	r3,r0		;reduce by one more
    102 000222  020002                  	cmp	r0,r2		;any more to search?
    103 000224  101756                  	blos	1$		;if los yes
    104 000226  060301                  	add	r3,r1		;point to proper entry
    105 000230  000404                  	br	5$		;exit
    106 000232  010102                  3$:	mov	r1,r2		;se new high limit
    107 000234  160302                  	sub	r3,r2		;reduce by one more
    108 000236  020002                  	cmp	r0,r2		;any more to search?
    109 000240  101750                  	blos	1$		;if los yes
    110 000242  005000                  5$:	clr	r0		;set false flag
    111 000244  005726                  6$:	tst	(sp)+		;clean stack
    112 000246  000451                  	br	scanx		;vammoosa
    113
    114 000250                          	genedt	reg
      1 000250                          	entsec	edtsec
      1 000000     016                  	.psect	edtsec	con
      2 000000  070517                  	.rad50	/reg/
      3              0=                 	.if nb
      4                                 	.word
      5              1=                 	.iff
      6 000002  000000G                 	.word	cpopj
      7                                 	.endc
      8 000004  000000G                 	.word	ed.reg
      9 000006                          	xitsec
      1 000006                          	entsec	.text
      1 000250     002                  	.psect	.text	con
    115
    116                                 	.endc


    117 000250                          next:				;get the next entry
    118 000250                          	call	setrol
      1 000250  004767  000626          	jsr	pc,setrol
    119 000254  016700  000010'         	mov	rolupd,r0
    120 000260  060001                  	add	r0,r1
    121 000262  060300                  	add	r3,r0
    122 000264  020102                  	cmp	r1,r2
    123 000266  103441                  	blo	scanx
    124 000270  000437                  	br	scanxf
    125
    126 000272                          scanw:				;scan one word
    127 000272                          	call	setrol		;set registers
      1 000272  004767  000604          	jsr	pc,setrol
    128 000276  005000                  	clr	r0		;assume false
    129 000300  005200                  1$:	inc	r0		;tally entry count
    130 000302  021411                  	cmp	(r4),(r1)	;match?
    131 000304  001437                  	beq	scany		;  yes
    132 000306  060301                  	add	r3,r1		;no, increment pointer
    133 000310  020102                  	cmp	r1,r2		;finished?
    134 000312  103772                  	blo	1$		;  no
    135 000314  005000                  	clr	r0
    136 000316                          	return			;yes, exit false
      1 000316  000207                  	rts	pc
    137
    138 000320                          scanc:				;scan continuation
    139 000320                          	call	setrof		;set regs
      1 000320  004767  000562          	jsr	pc,setrof
    140 000324  016701  000006'         	mov	rolpnt,r1	;get current pointer
    141 000330  060301                  	add	r3,r1		;update
    142 000332  000402                  	br	scanf		;jump into middle
    143
    144 000334                          scan:				;linear roll scan
    145 000334                          	call	setrol		;set roll registers
      1 000334  004767  000542          	jsr	pc,setrol
    146 000340  005000                  scanf:	clr	r0		;assume false
    147 000342  020102                  1$:	cmp	r1,r2		;end?
    148 000344  103011                  	bhis	scanxf		;  yes, exit false
    149 000346  005200                  	inc	r0
    150 000350  021411                  	cmp	(r4),(r1)	;no, match on first words?
    151 000352  001004                  	bne	2$		;  yes
    152 000354  026461  000002  000002  	cmp	2(r4),2(r1)	;no, how about second?
    153 000362  001403                  	beq	scanx		;  yes
    154 000364  060301                  2$:	add	r3,r1		;increment by size
    155 000366  000765                  	br	1$
    156
    157                                 	.enabl	lsb
    158 000370  005000                  scanxf:	clr	r0		;false exit
    159 000372  010167  000006'         scanx:	mov	r1,rolpnt	;set entry pointer
    160 000376  010067  000010'         	mov	r0,rolupd	;save flag
    161 000402  001404                  	beq	1$		;branch if not found
    162 000404  010402                  scany:	mov	r4,r2		;pointer to "symbol"
    163 000406  005403                  	neg	r3		;negate entry size
    164 000410  000163  000000G         	jmp	xmit0(r3)	;found, xfer arguments
    165
    166 000414  022424                  1$:	cmp	(r4)+,(r4)+	;bypass symbol itself
    167 000416  006203                  	asr	r3		;get word count
    168 000420  162703  000002          	sub	#2,r3		;compensate for above cmp
    169 000424  003402                  	ble	3$		;branch if end
    170 000426  005024                  2$:	clr	(r4)+		;clear word
    171 000430  077302                  	sob	r3,2$
    172 000432                          3$:	return
      1 000432  000207                  	rts	pc
    173                                 	.dsabl	lsb


    174 000434                          append:				;append to end of roll
    175 000434                          	call	setrol
      1 000434  004767  000442          	jsr	pc,setrol
    176 000440  010267  000006'         	mov	r2,rolpnt	;set pointer
    177 000444  005067  000010'         	clr	rolupd
    178 000450  000402                  	br	inserf
    179
    180 000452                          insert:				;insert in roll
    181 000452                          	call	setrof		;set roll registers (but no arg)
      1 000452  004767  000430          	jsr	pc,setrof
    182 000456  016700  000006'         inserf:	mov	rolpnt,r0	;points to proper slot
    183 000462  005767  000010'         	tst	rolupd		;was search true?
    184 000466  001045                  	bne	5$		;  yes
    185 000470  105265  000001'         	incb	<^pl rolsiz>+1(r5)	;update entry count
    186 000474  060365  000000'         	add	r3,<^pl roltop>(r5)	;update top pointer
    187 000500  020265  000002'         	cmp	r2,<^pl rolbas>+2(r5)	;gap between rolls?
    188 000504  001036                  	bne	5$		;  yes, just stuff it
    189 000506  016701  000000'         	mov	<^pl rolbas>,r1	;ditto for separate stack
    190 000512  010102                  	mov	r1,r2
    191 000514  160302                  	sub	r3,r2
    192 000516  010267  000014'         	mov	r2,symbot
    193                                 	;cmp	r2,mactop	;room?
    194                                 	;bhi	1$		;  yes
    195                                 	;jmp	symovf		;no, error
    196 000522  012767  000000G 000002' 	mov	#symovf,upbomb	; where to go on error
    197 000530                          	call	uplift
      1 000530  004767  000072          	jsr	pc,uplift
    198 000534  066700  000000'         	add	upgap,r0
    199 000540  066701  000000'         	add	upgap,r1
    200 000544  066702  000000'         	add	upgap,r2
    201
    202                                 	; fall through...
    203 000550  160100                  1$:	sub	r1,r0		;compute byte count
    204 000552  006200                  	asr	r0		;  now word count
    205 000554  001402                  	beq	4$		;branch if first time
    206
    207 000556  012122                  2$:	mov	(r1)+,(r2)+	;move an entry down
    208 000560  077002                  	sob	r0,2$
    209 000562  160365  000000'         4$:	sub	r3,<^pl rolbas>(r5)	;decrement pointers
    210 000566  160365  000000'         	sub	r3,<^pl roltop>(r5)
    211 000572  162705  000002          	sub	#2,r5		;more rolls?
    212 000576  002371                  	bge	4$		;  yes
    213 000600  010200                  	mov	r2,r0		;point to insertion slot
    214 000602  006203                  5$:	asr	r3		;halve size count
    215 000604  012420                  6$:	mov	(r4)+,(r0)+	;move an entry into place
    216 000606  077302                  	sob	r3,6$		;loop if not end
    217 000610  016767  000000' 000014' 	mov	<^pl rolbas>,symbot
    218 000616  016767  000000' 000000G 	mov	<^pl rolbas>,symlp
    219 000624                          	return
      1 000624  000207                  	rts	pc
    220
    221
    222                                 .globl	$brkad, $brksy		; defined in exec.m11
    223
    224                                 .globl	putn
    225 000626                          uplift::			;<<< REEDS. move all the rolls up in core
    226                                 				; can be called from 'insert' above and also
    227                                 				; from 'getblk' in mac.m11.  Thanks to Steve
    228                                 				; Ragle for showing the need for a call from
    229                                 				; otherwise growing macros can scribble.
    230                                 				; And to Joel Rubin for debugging help.
    231         000004                  	.irpc	xx,<0123>
    232                                 	mov	r'xx,-(sp)
    233                                 	.endm
      1 000626  010046                  	mov	r0,-(sp)
      2 000630  010146                  	mov	r1,-(sp)
      3 000632  010246                  	mov	r2,-(sp)
      4 000634  010346                  	mov	r3,-(sp)
    234 000636  026767  000014' 000012' 	cmp	symbot,mactop
    235 000644  101404                  	blos	10$
    236 000646  005067  000000'         	clr	upgap
    237 000652  000167  000174          	jmp	99$
    238 000656                          10$:				; go here if symbot <= mactop
    239
    240 000656  016767  000000G 000000' 	mov	symhp,upgap	; stash old highest in-space address
    241 000664  062767  010102  000000G 	add	#10102,symhp
    242 000672  042767  000077  000000G 	bic	#77,symhp	; click bic rounds to next highest mult of 64
    243
    244 000700  016767  000000G 000000G 	mov	symhp,$brkad
    245 000706  016746  000000G         	mov	$brkad,-(sp)
    246 000712  005746                  	tst	-(sp)
    247 000714  000000G                 	$sbrk
    248 000716  103402                  	bcs	98$
    249 000720  022626                  	cmp	(sp)+,(sp)+
    250 000722  000403                  	br	1$
    251 000724                          98$:
    252 000724  022626                  	cmp	(sp)+,(sp)+
    253 000726  000177  000002'         	jmp	@upbomb		; error bail-out: symovf or macovf
    254 000732                          1$:
    255 000732  162767  000002  000000G 	sub	#2,symhp	; new highest in-space address
    256 000740  016700  000000G         	mov	symhp,r0
    257 000744  016701  000000'         	mov	upgap,r1	; recall old highest address
    258 000750  010003                  	mov	r0,r3
    259 000752  160103                  	sub	r1,r3		; r3 has the distance syms were shifted
    260 000754  016702  000000G         	mov	symlp,r2	; symlp is OLD bottom of symbols.
    261 000760  005742                  	tst	-(r2)		; r2 ==> word before old bottom
    262 000762                          2$:
    263 000762  011110                  	mov	(r1),(r0)
    264 000764  005741                  	tst	-(r1)
    265 000766  005740                  	tst	-(r0)
    266 000770  020102                  	cmp	r1,r2
    267 000772  001373                  	bne	2$
    268
    269 000774  010367  000000'         9$:	mov	r3,upgap	; how much the syms were lifted
    270 001000  012700  000000G         	mov	#dumrol,r0	; swiped from srchi
    271 001004  060360  000000'         3$:	add	r3,<^pl rolbas>(r0)
    272 001010  060360  000000'         	add	r3,<^pl roltop>(r0)
    273 001014  162700  000002          	sub	#2,r0
    274 001020  002371                  	bge	3$
    275
    276 001022  060367  000006'         	add	r3,rolpnt
    277 001026  060367  000000G         	add	r3,symlp
    278 001032  016767  000000G 000014' 	mov	symlp,symbot
    279 001040  005767  000010'         	tst	rolupd
    280 001044  001402                  	beq	30$
    281 001046  060367  000010'         	add	r3,rolupd
    282 001052                          30$:
    283 001052                          99$:
    284         000004                  	.irpc	xx,<3210>
    285                                 	mov	(sp)+,r'xx
    286                                 	.endm
      1 001052  012603                  	mov	(sp)+,r3
      2 001054  012602                  	mov	(sp)+,r2
      3 001056  012601                  	mov	(sp)+,r1
      4 001060  012600                  	mov	(sp)+,r0
    287 001062                          	return
      1 001062  000207                  	rts	pc
    288
    289 001064                          	entsect	mixed
      1 000000     006                  	.psect	mixed	con
    290 000000  000001                  upgap:		.blkw
    291 000002  000001                  upbomb::	.blkw			; contains address of error handler
    292 000004                          	xitsec
      1 000004                          	entsec	.text
      1 001064     002                  	.psect	.text	con


    293 001064                          zap:				;empty a roll
    294 001064                          	call	setrol
      1 001064  004767  000012          	jsr	pc,setrol
    295 001070  010165  000000'         	mov	r1,<^pl roltop>(r5)	;make top = bottom
    296 001074  105065  000001'         	clrb	<^pl rolsiz>+1(r5)	;clear entry count
    297 001100                          	return
      1 001100  000207                  	rts	pc
    298
    299
    300 001102                          setrol:				;set roll registers
    301 001102  010067  000004'         	mov	r0,rolndx	;set argument
    302 001106  012600                  setrof:	mov	(sp)+,r0	;save return address
    303 001110                          	call	savreg		;save registers
      1 001110  004767  000000G         	jsr	pc,savreg
    304 001114  010546                  	mov	r5,-(sp)	;  and current character
    305 001116  016705  000004'         	mov	rolndx,r5	;set index
    306 001122  016501  000000'         	mov	<^pl rolbas>(r5),r1	;current base
    307 001126  016502  000000'         	mov	<^pl roltop>(r5),r2	;current top
    308 001132  116503  000000'         	movb	<^pl rolsiz>(r5),r3	;entry size
    309 001136  012704  000000G         	mov	#symbol,r4	;pointer to symbol
    310 001142                          	call	(r0)		;call proper routine
      1 001142  004710                  	jsr	pc,(r0)
    311 001144  012605                  	mov	(sp)+,r5	;restore current character
    312 001146                          	return			;  and rest of regs
      1 001146  000207                  	rts	pc
    313
    314 001150                          	entsec	mixed
      1 000004     006                  	.psect	mixed	con
    315 000004  000001                  rolndx:	.blkw			;roll index
    316 000006  000001                  rolpnt:	.blkw			;roll pointer
    317 000010  000001                  rolupd:	.blkw			;roll update
    318 000012  000001                  mactop:	.blkw			;current top of macro storage
    319 000014  000001                  symbot:	.blkw			;current bottom of dynamic rolls.
    320                                 				;	@mactop<=@symbot  or uplift will fix it
    321 000016                          	xitsec
      1 000016                          	entsec	.text
      1 001150     002                  	.psect	.text	con
    322
    323         000001                  	.end


Symbol table

APPEND  000434RG     002 INSERF  000456R      002 ROLUPD  000010RG     006 SETROF  001106R      002 UPBOMB  000002RG     006
BPMB  = 000020           INSERT  000452RG     002 RSX11D= 000000           SETROL  001102R      002 UPGAP   000000R      006
CPOPJ = ****** G         LF    = 000012           SAVREG= ****** G         SPACE = 000040           UPLIFT  000626RG     002
CR    = 000015           MACTOP  000012RG     006 SCAN    000334RG     002 SRCHI   000000RG     002 VT    = 000013          
DEBUG = 000000           MK.SYM= 000001           SCANC   000320RG     002 SYMBOL= ****** G         XMIT0 = ****** G        
DUMROL= ****** G         NEXT    000250RG     002 SCANF   000340R      002 SYMBOT  000014RG     006 X40   = 000000          
EDMASK= ****** G         PDPV45= 000000           SCANW   000272RG     002 SYMHP = ****** G         ZAP     001064RG     002
ED.REG= ****** G         PUTN  = ****** G         SCANX   000372R      002 SYMLP = ****** G         $BRKAD= ****** G        
FF    = 000014           REGROL= ****** G         SCANXF  000370R      002 SYMOVF= ****** G         $BRKSY= ****** G        
FT.ID = 000001           ROLNDX  000004RG     006 SCANY   000404R      002 SYMROL= ****** G         $SBRK = ****** GX       
FT.UNX= 000001           ROLPNT  000006R      006 SEARCH  000072RG     002 TAB   = 000011           $TIMDF= 000007          


Program sections

. ABS.  000000    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
.TEXT   001150    002   (RO,I,GBL,REL,CON,NOSAV)
.DATA   000000    003   (RW,D,GBL,REL,CON,NOSAV)
.BSS    000000    004   (RW,D,GBL,REL,CON,NOSAV)
DPURE   000000    005   (RW,D,GBL,REL,CON,NOSAV)
MIXED   000016    006   (RW,I,GBL,REL,CON,NOSAV)
ERRMES  000000    007   (RW,D,GBL,REL,CON,NOSAV)
IMPURE  000000    010   (RW,D,GBL,REL,CON,NOSAV)
IMPPAS  000000    011   (RW,D,GBL,REL,CON,NOSAV)
IMPLIN  000000    012   (RW,D,GBL,REL,CON,NOSAV)
SWTSEC  000000    013   (RW,D,GBL,REL,CON,NOSAV)
CNDSEC  000000    014   (RW,D,GBL,REL,CON,NOSAV)
CRFSEC  000000    015   (RW,D,GBL,REL,CON,NOSAV)
EDTSEC  000006    016   (RW,D,GBL,REL,CON,NOSAV)
LCTSEC  000000    017   (RW,D,GBL,REL,CON,NOSAV)
PSASEC  000000    020   (RW,D,GBL,REL,CON,NOSAV)
PSTSEC  000000    021   (RW,D,GBL,REL,CON,NOSAV)
ROLBAS  000000    022   (RW,D,GBL,REL,CON,NOSAV)
ROLSIZ  000000    023   (RW,D,GBL,REL,CON,NOSAV)
ROLTOP  000000    024   (RW,D,GBL,REL,CON,NOSAV)
XPCOR   000000    025   (RW,D,GBL,REL,CON,NOSAV)
