      1         000001                  debug=1
      1                                 	.title	at.sml	-   assembler/translator system macros
      2                                 	; @(#)at.sml	1.3 11/3/82
      3
      4                                 	.ident	/10may4/
      5
      6                                 	.macro	always		;all files of macro
      7
      8                                 	.macro	.data
      9                                 	entsec	.data
     10                                 	.endm	.data
     11
     12                                 	.macro	.text
     13                                 	entsec	.text
     14                                 	.endm
     15
     16                                 	.macro	.bss
     17                                 	entsec	.bss
     18                                 	.endm
     19
     20                                 mk.symbol=1			;one to make symbols, 0 otherwise
     21                                 x40=	0
     22                                 pdpv45=	0			; host machine has 'mul', 'div', sob' instrucs.
     23                                 				; if not you will have to write macros for them
     24                                 $timdf=	7			; California Time Zone
     25                                 				; should really use ftime(2) for this and for
     26                                 				; DST.
     27                                 ;xfltg=	0		;define to assmbl out floating hardware
     28                                 rsx11d	=	0	; rsx11d features
     29                                 debug	=	0	; <<< REEDS if non zero includes debug junk
     30
     31                                 ft.id=	1			;have set i & d.  set =0 if not
     32
     33                                 ft.unx = 1			; this macro-11 is for UNIX.  =0 if not.
     34
     35                                 	.nlist	bex
     36
     37                                 tab=	11
     38                                 lf=	12
     39                                 vt=	13
     40                                 ff=	14
     41                                 cr=	15
     42                                 space=	40
     43
     44                                 bpmb	=	20		;bytes per macro block
     45
     46
     47
     48
     49
     50                                 	.psect	.text	con, shr, gbl,ins
     51                                 	.psect	.data	con, dat, prv, gbl
     52                                 	.psect	.bss	con, bss, gbl
     53
     54                                 	.psect	dpure	con, dat, prv, gbl
     55                                 	.psect	mixed	con, prv, gbl
     56                                 	.psect	errmes	con, dat, prv, gbl
     57                                 	.psect	impure	con, bss, gbl
     58                                 	.psect	imppas	con, bss, gbl
     59                                 	.psect	implin	con, bss, gbl
     60                                 	.psect	swtsec	con, dat, prv, gbl	; unix command line flags
     61                                 	.psect	cndsec 	con, dat, prv, gbl	; gt, le, equ, etc.  for '.if'
     62                                 	.psect	crfsec 	con, dat, prv, gbl	; args for -cr flag
     63                                 	.psect	edtsec 	con, dat, prv, gbl	; args for .enabl
     64                                 	.psect	lctsec 	con, dat, prv, gbl	; args for .list
     65                                 	.psect	psasec 	con, dat, prv, gbl
     66                                 	.psect	pstsec 	con, dat, prv, gbl
     67                                 	.psect	rolbas 	con, dat, prv, gbl	; core allocation: starts of tables
     68                                 	.psect	rolsiz 	con, dat, prv, gbl	; sizes of table entries
     69                                 	.psect	roltop 	con, dat, prv, gbl	; tops of tables
     70                                 	.psect	xpcor	con,bss	, gbl	; this one MUST come last in core
     71
     72


     73                                 	.macro	entsec	name 	;init a section
     74                                 	.psect	name	con
     75                                 	.endm	entsec
     76
     77
     78
     79                                 	.macro jeq	x,?fred
     80                                 	bne	fred
     81                                 	jmp	x
     82                                 fred:
     83                                 	.endm
     84                                 	.macro	jne	x,?fred
     85                                 	beq	fred
     86                                 	jmp	x
     87                                 fred:
     88                                 	.endm
     89                                 	.macro	xitsec
     90                                 	entsec	.text
     91                                 	.endm	xitsec
     92
     93
     94                                 	.macro	call	address
     95                                 	jsr	pc,address
     96                                 	.endm
     97
     98                                 	.macro	return
     99                                 	rts	pc
    100                                 	.endm
    101
    102
    103                                 	.macro	always
    104                                 	.nlist	bex
    105                                 	.endm	always
    106                                 	.endm	always
    107
    108
    109         000001=                 	.if ne debug
    110
    111                                 	.macro	ndebug n
    112                                 	.globl	ndebug,..z
    113                                 	mov	n,..z
    114                                 	call	ndebug
    115                                 	.endm
    116
    117                                 	.macro	sdebug	string
    118                                 	.globl	sdebug,..z,..zbuf
    119                                 	x = 0
    120                                 	.irpc	t,<string>
    121                                 	movb	#''t,..zbuf+x
    122                                 	x = x+1
    123                                 	.endm
    124                                 	movb	#0,..zbuf+x
    125                                 	mov	#..zbuf,..z
    126                                 	call	sdebug
    127                                 	.endm
    128
    129              0=                 	.iff
    130
    131                                 	.macro	ndebug n
    132                                 	.endm
    133
    134                                 	.macro	sdebug	string
    135                                 	.endm
    136
    137                                 	.endc
    138
    139
    140                                 	.macro	param	mne,	value	;define default parameters
    141                                 	.iif ndf mne,	mne=	value
    142                                 	.list
    143                                 mne=	mne
    144                                 	.nlist
    145                                 	.endm


    146                                 	.macro	putkb	addr	;list to kb
    147                                 	.globl	putkb
    148                                 	mov	addr,r0
    149                                 	call	putkb
    150                                 	.endm
    151
    152                                 	.macro	putlp	addr	;list to lp
    153                                 	.globl	putlp
    154                                 	mov	addr,r0
    155                                 	call	putlp
    156                                 	.endm
    157
    158                                 	.macro	putkbl	addr	;list to kb and lp
    159                                 	.globl	putkbl
    160                                 	mov	addr,r0
    161                                 	call	putkbl
    162                                 	.endm
    163
    164
    165                                 	.macro	xmit	wrdcnt	;move small # of words
    166                                 	.globl	xmit0
    167                                 	call	xmit0-<wrdcnt*2>
    168                                 	.endm	xmit
    169
    170
    171                                 ;the macro "genswt" is used to specify  a command
    172                                 ;string switch (1st argument) and the address of
    173                                 ;the routine to be called when encountered (2nd arg).
    174                                 ; the switch is made upper-case.
    175
    176                                 	.macro	genswt	mne,addr,?label
    177                                 	entsec	swtsec
    178                                 label:	.irpc	x,mne
    179                                 	.if ge ''x-141
    180                                 		.if le ''x-172
    181                                 			.byte ''x-40
    182                                 		.iff
    183                                 			.byte ''x
    184                                 		.endc
    185                                 	.iff
    186                                 	.byte ''x
    187                                 	.endc
    188                                 	.endm
    189                                 	.iif ne <.-label&1>,	.byte	0
    190                                 	.word	addr
    191                                 	xitsec
    192                                 	.endm


    193                                 	.macro	zread	chan
    194                                 	.globl	zread
    195                                 	mov	#chan'chn,r0
    196                                 	call	zread
    197                                 	.endm	zread
    198
    199                                 	.macro	zwrite	chan
    200                                 	.globl	zwrite
    201                                 	mov	#chan'chn,r0
    202                                 	call	zwrite
    203                                 	.endm	zwrite


    204                                 	.macro	genedt	mne,subr	;gen enable/disable table
    205                                 	entsec	edtsec
    206                                 	.rad50	/mne/
    207                                 	.if nb	subr
    208                                 	.word	subr
    209                                 	.iff
    210                                 	.word	cpopj
    211                                 	.endc
    212                                 	.word	ed.'mne
    213                                 	xitsec
    214                                 	.endm	genedt
    215
    216
    217                                 ;the macro "gencnd" is used to specify conditional
    218                                 ;arguments.  it takes two or three arguments:
    219
    220                                 ;	1-	mnemonic
    221                                 ;	2-	subroutine to be called
    222                                 ;	3-	if non-blank, complement condition
    223
    224                                 	.macro	gencnd	mne,subr,toggle	;generate conditional
    225                                 	entsec	cndsec
    226                                 	.rad50	/mne/
    227                                 	.if b	<toggle>
    228                                 	.word	subr
    229                                 	.iff
    230                                 	.word	subr+1
    231                                 	.endc
    232                                 	xitsec
    233                                 	.endm


    234                                 	.macro	ch.mne
    235
    236                                 ch.ior=	'!
    237                                 ch.qtm=	'"
    238                                 ch.hsh=	'#
    239                                 ch.dol=	'$
    240                                 ch.pct=	'%
    241                                 ch.and=	'&
    242                                 ch.xcl=	''
    243
    244                                 ch.lp=	'(
    245                                 ch.rp=	')
    246                                 ch.mul=	'*
    247                                 ch.add=	'+
    248                                 ch.com=	',
    249                                 ch.sub=	'-
    250                                 ch.dot=	'.
    251                                 ch.div=	'/
    252
    253                                 ch.col=	':
    254                                 ch.smc=	';
    255                                 ch.lab=	'<
    256                                 ch.equ=	'=
    257                                 ch.rab=	'>
    258                                 ch.qm=	'?
    259
    260                                 ch.ind=	'@
    261                                 ch.bsl=	'\
    262                                 ch.uar=	'^
    263
    264                                 let.a=	'a&^c40
    265                                 let.b=	'b&^c40
    266                                 let.c=	'c&^c40
    267                                 let.d=	'd&^c40
    268                                 let.e=	'e&^c40
    269                                 let.f=	'f&^c40
    270                                 let.g=	'g&^c40
    271                                 let.o=	'o&^c40
    272                                 let.p=	'p&^c40
    273                                 let.r=	'r&^c40
    274                                 let.z=	'z&^c40
    275
    276                                 dig.0=	'0
    277                                 dig.9=	'9
    278                                 	.macro	ch.mne
    279                                 	.endm	ch.mne
    280                                 	.endm	ch.mne
    281
    282                                 	.macro error num,arg, mess ,?x
    283                                 	sdebug	<num>
    284                                 	.globl	err.'arg,ern'num, errbts,errref
    285                                 	.if	b	<mess>
    286                                 	deliberate error mistake
    287                                 	.endc
    288                                 	.if	dif	0,num
    289                                 	.globl	err.xx
    290                                 	tst	err.xx
    291                                 	bne	x
    292                                 	mov	#ern'num,err.xx
    293                                 x:
    294                                 	.endc
    295                                 	bis	#err.'arg,errbts
    296                                 	.endm
    297
    298
    299
    300                                 	.macro	setnz	addr	;set addr to non-zero for t/f flags
    301                                 	mov	sp,addr
    302                                 	.endm
    303
    304
    305                                 	.macro	bisbic	arg	; used by .list/.nlist, .enabl/.dsabl
    306                                 	.globl	bisbic
    307                                 	mov	#arg,-(sp)
    308                                 	call	bisbic
    309                                 	tst	(sp)+
    310                                 	.endm


    311                                 				;roll handler calls
    312
    313                                 	.macro	search	rolnum	;binary search
    314                                 	mov	#rolnum,r0
    315                                 	.globl	search
    316                                 	call	search
    317                                 	.endm
    318
    319                                 	.macro	scan	rolnum	;linear scan
    320                                 	mov	#rolnum,r0
    321                                 	.globl	scan
    322                                 	call	scan
    323                                 	.endm
    324
    325                                 	.macro	scanw	rolnum	;linear scan, one word
    326                                 	mov	#rolnum,r0
    327                                 	.globl	scanw
    328                                 	call	scanw
    329                                 	.endm
    330
    331                                 	.macro	next	rolnum	;fetch next entry
    332                                 	mov	#rolnum,r0
    333                                 	.globl	next
    334                                 	call	next
    335                                 	.endm
    336
    337                                 	.macro	append	rolnum	;append to end of roll
    338                                 	mov	#rolnum,r0
    339                                 	.globl	append
    340                                 	call	append
    341                                 	.endm
    342
    343                                 	.macro	zap	rolnum	;clear roll
    344                                 	mov	#rolnum,r0
    345                                 	.globl	zap
    346                                 	call	zap
    347                                 	.endm
    348
    349                                 ;	call	insert		;insert (must be preceded by one
    350                                 				;of the above to set pointers)
    351                                 ;	call	setrol		;save and set regs for above


    352                                 ;flags used in symbol table mode
    353
    354                                 	.macro	st.flg
    355
    356                                 .if le ft.unx
    357
    358                                 ovrflg=	000004		;overlay (psect only)
    359                                 defflg=	000010		;defined
    360                                 relflg=	000040		;relocatable
    361                                 glbflg=	000100		;global
    362                                 dfgflg= 000200		; default global <rsx11d>... reeds's guess
    363
    364
    365                                 .endc
    366
    367                                 .if gt ft.unx
    368
    369                                 			; ****** these should not be changed!! ******
    370                                 shrflg=	000001		;shareable (psect only)
    371                                 .if gt ft.id
    372                                 insflg=	shrflg*2	;instruction space (psect only)
    373                                 bssflg=	insflg*2	;blank section (psect only)
    374                                 m.idf=	shrflg!insflg!bssflg	;mask to turn them off
    375                                 .iff
    376                                 bssflg=	shrflg*2
    377                                 m.idf=	shrflg!bssflg
    378                                 .endc
    379                                 b.idf=	1		;shift count to make above bits word offset
    380                                 			; ***********************************
    381                                 defflg=	000010		;defined
    382                                 ovrflg=	000020		;overlay (psect only)
    383                                 relflg=	000040		;relocatable
    384                                 glbflg=	000100		;global
    385                                 dfgflg= 000200		; default global <rsx11d>... reeds's guess
    386
    387                                 .endc
    388
    389                                 ;
    390                                 ; default psect attribs.
    391                                 ; can be changed, but make sure all customers know about
    392                                 ; it, including all the linkers.
    393                                 ;
    394                                 pattrs=relflg!defflg		; For .psects and blank .csects
    395                                 aattrs=glbflg!defflg!ovrflg		; For .asect
    396                                 cattrs=glbflg!relflg!defflg!ovrflg	; For named .csects
    397
    398                                 regflg=	000001		;register
    399                                 lblflg=	000002		;label
    400                                 mdfflg=	000004		;multilpy defined
    401                                 	.macro	st.flg
    402                                 	.endm
    403                                 	.endm	st.flg
    404
    405
    406
    407                                 	.macro	ct.mne
    408                                 	.globl	cttbl
    409                                 ct.eol	=	000		; eol
    410                                 ct.com	=	001		; comma
    411                                 ct.tab	=	002		; tab
    412                                 ct.sp	=	004		; space
    413                                 ct.pcx	=	010		; printing character
    414                                 ct.num	=	020		; numeric
    415                                 ct.alp	=	040		; alpha, dot, dollar
    416                                 ct.lc	=	100		; lower case alpha
    417                                 ct.smc	=	200		; semi-colon (sign bit)
    418
    419                                 ct.pc	=	ct.com!ct.smc!ct.pcx!ct.num!ct.alp
    420                                 	.macro	ct.mne
    421                                 	.endm	ct.mne
    422                                 	.endm	ct.mne
    423
    424
    425         000001                  	.end


      1                                 	.title	fltg
      2
      3                                 	.ident	/27dec3/
      4
      5                                 	.mcall	(at)always,xmit,genedt,error
      6                                 	.mcall	(at)sdebug,ndebug
      7 000000                          	always
      1
      2                                 	.macro	.data
      3                                 	entsec	.data
      4                                 	.endm	.data
      5
      6                                 	.macro	.text
      7                                 	entsec	.text
      8                                 	.endm
      9
     10                                 	.macro	.bss
     11                                 	entsec	.bss
     12                                 	.endm
     13
     14         000001                  mk.symbol=1			;one to make symbols, 0 otherwise
     15         000000                  x40=	0
     16         000000                  pdpv45=	0			; host machine has 'mul', 'div', sob' instrucs.
     17                                 				; if not you will have to write macros for them
     18         000007                  $timdf=	7			; California Time Zone
     19                                 				; should really use ftime(2) for this and for
     20                                 				; DST.
     21                                 ;xfltg=	0		;define to assmbl out floating hardware
     22         000000                  rsx11d	=	0	; rsx11d features
     23         000000                  debug	=	0	; <<< REEDS if non zero includes debug junk
     24
     25         000001                  ft.id=	1			;have set i & d.  set =0 if not
     26
     27         000001                  ft.unx = 1			; this macro-11 is for UNIX.  =0 if not.
     28
     29                                 	.nlist	bex
     30
     31         000011                  tab=	11
     32         000012                  lf=	12
     33         000013                  vt=	13
     34         000014                  ff=	14
     35         000015                  cr=	15
     36         000040                  space=	40
     37
     38         000020                  bpmb	=	20		;bytes per macro block
     39
     40
     41
     42
     43
     44 000000     002                  	.psect	.text	con, shr, gbl,ins
     45 000000     003                  	.psect	.data	con, dat, prv, gbl
     46 000000     004                  	.psect	.bss	con, bss, gbl
     47
     48 000000     005                  	.psect	dpure	con, dat, prv, gbl
     49 000000     006                  	.psect	mixed	con, prv, gbl
     50 000000     007                  	.psect	errmes	con, dat, prv, gbl
     51 000000     010                  	.psect	impure	con, bss, gbl
     52 000000     011                  	.psect	imppas	con, bss, gbl
     53 000000     012                  	.psect	implin	con, bss, gbl
     54 000000     013                  	.psect	swtsec	con, dat, prv, gbl	; unix command line flags
     55 000000     014                  	.psect	cndsec 	con, dat, prv, gbl	; gt, le, equ, etc.  for '.if'
     56 000000     015                  	.psect	crfsec 	con, dat, prv, gbl	; args for -cr flag
     57 000000     016                  	.psect	edtsec 	con, dat, prv, gbl	; args for .enabl
     58 000000     017                  	.psect	lctsec 	con, dat, prv, gbl	; args for .list
     59 000000     020                  	.psect	psasec 	con, dat, prv, gbl
     60 000000     021                  	.psect	pstsec 	con, dat, prv, gbl
     61 000000     022                  	.psect	rolbas 	con, dat, prv, gbl	; core allocation: starts of tables
     62 000000     023                  	.psect	rolsiz 	con, dat, prv, gbl	; sizes of table entries
     63 000000     024                  	.psect	roltop 	con, dat, prv, gbl	; tops of tables
     64 000000     025                  	.psect	xpcor	con,bss	, gbl	; this one MUST come last in core
     65
     66
     67                                 	.macro	entsec	name 	;init a section
     68                                 	.psect	name	con
     69                                 	.endm	entsec
     70
     71
     72
     73                                 	.macro jeq	x,?fred
     74                                 	bne	fred
     75                                 	jmp	x
     76                                 fred:
     77                                 	.endm
     78                                 	.macro	jne	x,?fred
     79                                 	beq	fred
     80                                 	jmp	x
     81                                 fred:
     82                                 	.endm
     83                                 	.macro	xitsec
     84                                 	entsec	.text
     85                                 	.endm	xitsec
     86
     87
     88                                 	.macro	call	address
     89                                 	jsr	pc,address
     90                                 	.endm
     91
     92                                 	.macro	return
     93                                 	rts	pc
     94                                 	.endm
     95
     96
     97                                 	.macro	always
     98                                 	.nlist	bex
     99                                 	.endm	always
      8
      9                                 	.globl	savreg,	abstrm,	chrpnt,	cpopj,	cradix
     10                                 	.globl	getchr,	getnb,	mode
     11                                 	.globl	setnb,	stcode,	tstarg,	value
     12                                 	.globl	edmask,	ed.fpt
     13
     14
     15              1=                 	.if ndf	xfltg
     16
     17                                 	.globl	flt2,	flt4,	fltg1w
     18
     19 000000                          	xitsec			;start in default sector
      1 000000                          	entsec	.text
      1 000000     002                  	.psect	.text	con
     20
     21
     22 000000  005203                  flt4:	inc	r3
     23 000002                          flt2:
     24 000002  005203                  	inc	r3		;make it 1 or 2
     25 000004  006303                  	asl	r3		;now 2 or 4
     26 000006                          fp.1:	call	tstarg
      1 000006  004767  000000G         	jsr	pc,tstarg
     27 000012  001440                  	beq	fp.9
     28 000014  016346  177776'         	mov	fltpnt-2(r3),-(sp)	;evaluate number
     29 000020                          	call	@(sp)+
      1 000020  004736                  	jsr	pc,@(sp)+
     30 000022  001024                  	bne	fp.2		;branch if non-null
     31 000024                          	error	9,a,<empty floating point number>		;  null, flag error
      1 000024                          	sdebug	<9>
      1                                 	.globl	sdebug,..z,..zbuf
      2         000000                  	x = 0
      3         000001                  	.irpc	t,<9>
      4                                 	movb	#''t,..zbuf+x
      5                                 	x = x+1
      6                                 	.endm
      1 000024  112767  000071  000000G 	movb	#'9,..zbuf+x
      2         000001                  	x = x+1
      7 000032  112767  000000  000001G 	movb	#0,..zbuf+x
      8 000040  012767  000000G 000000G 	mov	#..zbuf,..z
      9 000046                          	call	sdebug
      1 000046  004767  000000G         	jsr	pc,sdebug
      2                                 	.globl	err.a,ern9, errbts,errref
      3              0=                 	.if	b	<empty floating point number>
      4                                 	deliberate error mistake
      5                                 	.endc
      6              1=                 	.if	dif	0,9
      7                                 	.globl	err.xx
      8 000052  005767  000000G         	tst	err.xx
      9 000056  001003                  	bne	30000$
     10 000060  012767  000000G 000000G 	mov	#ern9,err.xx
     11 000066                          30000$:
     12                                 	.endc
     13 000066  052767  000000G 000000G 	bis	#err.a,errbts
     32 000074  010302                  fp.2:	mov	r3,r2		;get a working count
     33 000076  012701  000010'         	mov	#fltbuf,r1	;point to floating point buffer
     34 000102  012114                  3$:	mov	(r1)+,(r4)	;move in next number
     35 000104                          	call	stcode		;place on code roll
      1 000104  004767  000000G         	jsr	pc,stcode
     36 000110  077204                  	sob	r2,3$		;loop on word count
     37 000112  000735                  	br	fp.1		;continue
     38
     39 000114                          fp.9:	return
      1 000114  000207                  	rts	pc
     40
     41 000116                          	entsec	dpure
      1 000000     005                  	.psect	dpure	con
     42 000000  000122' 000116'         fltpnt:	.word	fltg2w,	fltg4w
     43 000004                          	xitsec
      1 000004                          	entsec	.text
      1 000116     002                  	.psect	.text	con
     44
     45              1=                 	.if ndf	xedfpt
     46 000116                          	genedt	fpt		;floating point truncation
      1 000116                          	entsec	edtsec
      1 000000     016                  	.psect	edtsec	con
      2 000000  024024                  	.rad50	/fpt/
      3              0=                 	.if nb
      4                                 	.word
      5              1=                 	.iff
      6 000002  000000G                 	.word	cpopj
      7                                 	.endc
      8 000004  000000G                 	.word	ed.fpt
      9 000006                          	xitsec
      1 000006                          	entsec	.text
      1 000116     002                  	.psect	.text	con
     47                                 	.endc
     48


     49 000116  005267  000000'         fltg4w:	inc	fltwdc		;floating point number evaluator
     50 000122  005267  000000'         fltg2w:	inc	fltwdc
     51 000126                          fltg1w:
     52 000126                          	call	savreg		;save registers
      1 000126  004767  000000G         	jsr	pc,savreg
     53 000132  016746  000000G         	mov	chrpnt,-(sp)	;stack current character pointer
     54 000136  012703  000010'         	mov	#fltbuf,r3	;convenient copy of pointers
     55 000142  012704  000020'         	mov	#fltsav,r4	;  to buffer and save area
     56 000146  010401                  	mov	r4,r1
     57 000150  005041                  1$:	clr	-(r1)		;init variables
     58 000152  020127  000000'         	cmp	r1,#fltbeg
     59 000156  101374                  	bhi	1$		;loop until done
     60 000160  012767  000101  000006' 	mov	#65.,fltbex	;init binary exponent
     61 000166  022705  000053          	cmp	#'+,r5		;  "+"?
     62 000172  001406                  	beq	10$		;  yes, bypass and ignore
     63 000174  022705  000055          	cmp	#'-,r5		; "-"?
     64 000200  001005                  	bne	11$		;  no
     65 000202  012767  100000  000000' 	mov	#100000,fltsgn	;yes, set sign and bypass char
     66 000210                          10$:	call	getchr		;get the next character
      1 000210  004767  000000G         	jsr	pc,getchr
     67 000214  020527  000060          11$:	cmp	r5,#'0		;numeric?
     68 000220  103431                  	blo	20$
     69 000222  020527  000071          	cmp	r5,#'9
     70 000226  101026                  	bhi	20$		;  no
     71 000230  032713  174000          	bit	#174000,(r3)	;numeric, room for multiplication?
     72 000234  001403                  	beq	12$		;  yes
     73 000236  005267  000004'         	inc	fltexp		;no, compensate for the snub
     74 000242  000413                  	br	13$
     75
     76 000244                          12$:	call	fltm50		;multiply by 5
      1 000244  004767  000660          	jsr	pc,fltm50
     77 000250                          	call	fltgls		;correction, make that *10
      1 000250  004767  000730          	jsr	pc,fltgls
     78 000254  162705  000060          	sub	#'0,r5		;make absolute
     79 000260  010402                  	mov	r4,r2		;point to end of buffer
     80 000262  060542                  	add	r5,-(r2)	;add in
     81 000264  005542                  	adc	-(r2)		;ripple carry
     82 000266  005542                  	adc	-(r2)
     83 000270  005542                  	adc	-(r2)
     84 000272  066767  000002' 000004' 13$:	add	fltdot,fltexp	;decrement if processing fraction
     85 000300  005016                  	clr	(sp)		;clear initial char pointer (we're good)
     86 000302  000742                  	br	10$		;try for more
     87
     88 000304  022705  000056          20$:	cmp	#'.,r5		;decimal point?
     89 000310  001003                  	bne	21$		;  no
     90 000312  005167  000002'         	com	fltdot		;yes, mark it
     91 000316  100734                  	bmi	10$		;loop if first time around
     92 000320  022705  000105          21$:	cmp	#105,r5		;exponent?(routine  is passed upper case)
     93 000324  001015                  	bne	fltg3		;  no
     94 000326                          	call	getnb		;yes, bypass "e" and blanks
      1 000326  004767  000000G         	jsr	pc,getnb
     95 000332  016746  000000G         	mov	cradix,-(sp)	;stack current radix
     96 000336  012767  000012  000000G 	mov	#10.,cradix	;set to decimal
     97 000344                          	call	abstrm		;absolute term
      1 000344  004767  000000G         	jsr	pc,abstrm
     98 000350  012667  000000G         	mov	(sp)+,cradix	;restore radix
     99 000354  060067  000004'         	add	r0,fltexp	;update exponent
    100                                 ;	br	fltg3		;fall through


    101 000360  010301                  fltg3:	mov	r3,r1
    102 000362  012100                  	mov	(r1)+,r0	;test for zero
    103 000364  052100                  	bis	(r1)+,r0
    104 000366  052100                  	bis	(r1)+,r0
    105 000370  052100                  	bis	(r1)+,r0
    106 000372                          	jeq	fltgex		;exit if so
      1 000372  001002                  	bne	30001$
      2 000374  000167  000440          	jmp	fltgex
      3 000400                          30001$:
    107 000400  005767  000004'         31$:	tst	fltexp		;time to scale
    108 000404  001461                  	beq	fltg5		;fini if zero
    109 000406  002424                  	blt	41$		;divide if .lt. zero
    110 000410  021327  031426          	cmp	(r3),#031426	;multiply, can we *5?
    111 000414  101005                  	bhi	32$		;  no
    112 000416                          	call	fltm50		;yes, multiply by 5
      1 000416  004767  000506          	jsr	pc,fltm50
    113 000422  005267  000006'         	inc	fltbex		;  and by two
    114 000426  000405                  	br	33$
    115
    116 000430                          32$:	call	fltm54		;multiply by 5/4
      1 000430  004767  000440          	jsr	pc,fltm54
    117 000434  062767  000003  000006' 	add	#3.,fltbex	;  and by 8
    118 000442  005367  000004'         33$:	dec	fltexp		;  over 10
    119 000446  000754                  	br	31$
    120
    121 000450  005367  000006'         40$:	dec	fltbex		;division, left justify bits
    122 000454                          	call	fltgls
      1 000454  004767  000524          	jsr	pc,fltgls
    123 000460  005713                  41$:	tst	(r3)		;sign bit set?
    124 000462  100372                  	bpl	40$		;  no, loop
    125 000464  012746  000040          	mov	#16.*2,-(sp)	;16 outer, 2 inner
    126 000470                          	call	fltgrs		;shift right
      1 000470  004767  000472          	jsr	pc,fltgrs
    127 000474                          	call	fltgsv		;place in save buffer
      1 000474  004767  000520          	jsr	pc,fltgsv
    128 000500  032716  000001          42$:	bit	#1,(sp)		;odd lap?
    129 000504  001004                  	bne	43$		;  yes
    130 000506                          	call	fltgrs		;move a couple of bits right
      1 000506  004767  000454          	jsr	pc,fltgrs
    131 000512                          	call	fltgrs
      1 000512  004767  000450          	jsr	pc,fltgrs
    132 000516                          43$:	call	fltgrs		;once more to the right
      1 000516  004767  000444          	jsr	pc,fltgrs
    133 000522                          	call	fltgad		;add in save buffer
      1 000522  004767  000416          	jsr	pc,fltgad
    134 000526  005316                  	dec	(sp)		;end of loop?
    135 000530  003363                  	bgt	42$		;  no
    136 000532  005726                  	tst	(sp)+		;yes, prune stack
    137 000534  162767  000003  000006' 	sub	#3.,fltbex
    138 000542  005267  000004'         	inc	fltexp
    139 000546  000714                  	br	31$


    140 000550  005367  000006'         fltg5:	dec	fltbex		;left justift
    141 000554                          	call	fltgls
      1 000554  004767  000424          	jsr	pc,fltgls
    142 000560  103373                  	bcc	fltg5		;lose one bit
    143 000562  062767  000200  000006' 	add	#200,fltbex	;set excess 128.
    144 000570  003403                  	ble	2$		;branch if under-flow
    145 000572  105767  000007'         	tstb	fltbex+1	;high order zero?
    146 000576  001427                  	beq	fg53$		;  yes
    147 000600                          2$:	error	10,n,<floating point overflow>		;no, error
      1 000600                          	sdebug	<10>
      1                                 	.globl	sdebug,..z,..zbuf
      2         000000                  	x = 0
      3         000002                  	.irpc	t,<10>
      4                                 	movb	#''t,..zbuf+x
      5                                 	x = x+1
      6                                 	.endm
      1 000600  112767  000061  000000G 	movb	#'1,..zbuf+x
      2         000001                  	x = x+1
      3 000606  112767  000060  000001G 	movb	#'0,..zbuf+x
      4         000002                  	x = x+1
      7 000614  112767  000000  000002G 	movb	#0,..zbuf+x
      8 000622  012767  000000G 000000G 	mov	#..zbuf,..z
      9 000630                          	call	sdebug
      1 000630  004767  000000G         	jsr	pc,sdebug
      2                                 	.globl	err.n,ern10, errbts,errref
      3              0=                 	.if	b	<floating point overflow>
      4                                 	deliberate error mistake
      5                                 	.endc
      6              1=                 	.if	dif	0,10
      7                                 	.globl	err.xx
      8 000634  005767  000000G         	tst	err.xx
      9 000640  001003                  	bne	30002$
     10 000642  012767  000000G 000000G 	mov	#ern10,err.xx
     11 000650                          30002$:
     12                                 	.endc
     13 000650  052767  000000G 000000G 	bis	#err.n,errbts
    148 000656  010402                  fg53$:	mov	r4,r2		;set to shift eight bits
    149 000660  010201                  	mov	r2,r1
    150 000662  005741                  	tst	-(r1)		;r1 is one lower than r2
    151 000664  024142                  4$:	cmp	-(r1),-(r2)	;down one word
    152 000666  111112                  	movb	(r1),(r2)	;move up a byte
    153 000670  000312                  	swab	(r2)		;beware of the inside-out pc!!
    154 000672  020203                  	cmp	r2,r3		;end?
    155 000674  001373                  	bne	4$
    156 000676                          	call	fltgrs		;shift one place right
      1 000676  004767  000264          	jsr	pc,fltgrs
    157 000702  006014                  	ror	(r4)		;set high carry
    158              1=                 	.if ndf	xedfpt
    159 000704  032767  000000G 000000G 	bit	#ed.fpt,edmask	;truncation?
    160 000712  001450                  	beq	fp57$		;  yes
    161                                 	.endc
    162 000714  016702  000000'         	mov	fltwdc,r2	;get size count
    163 000720  006302                  	asl	r2		;double
    164 000722  001001                  	bne	8$		;preset type
    165 000724  005202                  	inc	r2		;single word
    166 000726  006302                  8$:	asl	r2		;convert to bytes
    167 000730  052762  077777  000010' 	bis	#077777,fltbuf(r2)
    168 000736  000261                  	sec
    169 000740  005562  000010'         5$:	adc	fltbuf(r2)
    170 000744  005302                  	dec	r2
    171 000746  005302                  	dec	r2
    172 000750  002373                  	bge	5$
    173 000752  005713                  	tst	(r3)		;test sign position
    174 000754  100027                  	bpl	fp57$		;ok if positive
    175 000756                          6$:	error	11,t,<trunctation error>
      1 000756                          	sdebug	<11>
      1                                 	.globl	sdebug,..z,..zbuf
      2         000000                  	x = 0
      3         000002                  	.irpc	t,<11>
      4                                 	movb	#''t,..zbuf+x
      5                                 	x = x+1
      6                                 	.endm
      1 000756  112767  000061  000000G 	movb	#'1,..zbuf+x
      2         000001                  	x = x+1
      3 000764  112767  000061  000001G 	movb	#'1,..zbuf+x
      4         000002                  	x = x+1
      7 000772  112767  000000  000002G 	movb	#0,..zbuf+x
      8 001000  012767  000000G 000000G 	mov	#..zbuf,..z
      9 001006                          	call	sdebug
      1 001006  004767  000000G         	jsr	pc,sdebug
      2                                 	.globl	err.t,ern11, errbts,errref
      3              0=                 	.if	b	<trunctation error>
      4                                 	deliberate error mistake
      5                                 	.endc
      6              1=                 	.if	dif	0,11
      7                                 	.globl	err.xx
      8 001012  005767  000000G         	tst	err.xx
      9 001016  001003                  	bne	30003$
     10 001020  012767  000000G 000000G 	mov	#ern11,err.xx
     11 001026                          30003$:
     12                                 	.endc
     13 001026  052767  000000G 000000G 	bis	#err.t,errbts
    176 001034  066713  000000'         fp57$:	add	fltsgn,(r3)	;set sign, if any
    177 001040  005067  000000G         fltgex:	clr	mode		;make absolute
    178 001044  005067  000000'         	clr	fltwdc		;clear count
    179 001050  011367  000000G         	mov	(r3),value	;place first guy in value
    180 001054  012600                  	mov	(sp)+,r0	;origional char pointer
    181 001056  001403                  	beq	1$		;zero (good) if any digits processed
    182 001060  010067  000000G         	mov	r0,chrpnt	;none, reset to where we came in
    183 001064  005003                  	clr	r3		;flag as false
    184 001066  010300                  1$:	mov	r3,r0		;set flag in r0
    185 001070  000167  000000G         	jmp	setnb		;return with non-blank


    186 001074                          fltm54:				;*5/4
    187 001074  021327  146314          	cmp	(r3),#146314	;room?
    188 001100  103404                  	blo	1$
    189 001102                          	call	fltgrs
      1 001102  004767  000060          	jsr	pc,fltgrs
    190 001106  005267  000006'         	inc	fltbex
    191 001112                          1$:	call	fltgsv		;save in backup
      1 001112  004767  000102          	jsr	pc,fltgsv
    192 001116                          	call	fltgrs		;scale right
      1 001116  004767  000044          	jsr	pc,fltgrs
    193 001122                          	call	fltgrs
      1 001122  004767  000040          	jsr	pc,fltgrs
    194 001126  000406                  	br	fltgad
    195
    196 001130                          fltm50:				;*5
    197 001130                          	call	fltgsv
      1 001130  004767  000064          	jsr	pc,fltgsv
    198 001134                          	call	fltgls
      1 001134  004767  000044          	jsr	pc,fltgls
    199 001140                          	call	fltgls
      1 001140  004767  000040          	jsr	pc,fltgls
    200
    201 001144                          fltgad:				;add save buffer to fltbuf
    202 001144  010402                  	mov	r4,r2		;point to save area
    203 001146  066242  000006          1$:	add	6(r2),-(r2)	;add in word
    204 001152  010201                  	mov	r2,r1		;set for carries
    205 001154  005541                  2$:	adc	-(r1)		;add in
    206 001156  103776                  	bcs	2$		;continue ripple, if necessary
    207 001160  020203                  	cmp	r2,r3		;through?
    208 001162  001371                  	bne	1$		;  no
    209 001164                          	return
      1 001164  000207                  	rts	pc


    210 001166  000241                  fltgrs:	clc			;right shift
    211 001170  010301                  	mov	r3,r1		;right rotate
    212 001172  006021                  	ror	(r1)+
    213 001174  006021                  	ror	(r1)+
    214 001176  006021                  	ror	(r1)+
    215 001200  006021                  	ror	(r1)+
    216 001202                          	return
      1 001202  000207                  	rts	pc
    217
    218 001204                          fltgls:				;left shift
    219 001204  010402                  	mov	r4,r2
    220 001206  006342                  	asl	-(r2)
    221 001210  006142                  	rol	-(r2)
    222 001212  006142                  	rol	-(r2)
    223 001214  006142                  	rol	-(r2)
    224 001216                          	return
      1 001216  000207                  	rts	pc
    225
    226 001220  010301                  fltgsv:	mov	r3,r1		;move fltbuf to fltsav
    227 001222  010402                  	mov	r4,r2
    228 001224                          	xmit	4
      1                                 	.globl	xmit0
      2 001224                          	call	xmit0-<4*2>
      1 001224  004767  177770G         	jsr	pc,xmit0-<4*2>
    229 001230                          	return
      1 001230  000207                  	rts	pc
    230
    231
    232 001232                          	entsec	impure
      1 000000     010                  	.psect	impure	con
    233 000000                          fltbeg:				;start of floating point impure
    234 000000  000001                  fltsgn:	.blkw			;sign bit
    235 000002  000001                  fltdot:	.blkw			;decimal point flag
    236 000004  000001                  fltexp:	.blkw			;decimal exponent
    237 000006  000001                  fltbex:	.blkw	1		;binary exponent (must preceed fltbuf)
    238 000010  000004                  fltbuf:	.blkw	4		;main ac
    239 000020  000004                  fltsav:	.blkw	4
    240
    241 000030                          	entsec	implin
      1 000000     012                  	.psect	implin	con
    242 000000  000001                  fltwdc:	.blkw			;word count
    243
    244 000002                          	xitsec
      1 000002                          	entsec	.text
      1 001232     002                  	.psect	.text	con
    245
    246
    247                                 	.endc
    248
    249         000001                  	.end


Symbol table

ABSTRM= ****** G         ERR.N = ****** G         FLTG1W  000126RG     002 FP.9    000114R      002 STCODE= ****** G        
BPMB  = 000020           ERR.T = ****** G         FLTG2W  000122R      002 FP57$   001034R      002 TAB   = 000011          
CHRPNT= ****** G         ERR.XX= ****** G         FLTG3   000360R      002 FT.ID = 000001           TSTARG= ****** G        
CPOPJ = ****** G         FF    = 000014           FLTG4W  000116R      002 FT.UNX= 000001           VALUE = ****** G        
CR    = 000015           FG53$   000656R      002 FLTG5   000550R      002 GETCHR= ****** G         VT    = 000013          
CRADIX= ****** G         FLTBEG  000000R      010 FLTM50  001130R      002 GETNB = ****** G         X     = 000002          
DEBUG = 000000           FLTBEX  000006R      010 FLTM54  001074R      002 LF    = 000012           XMIT0 = ****** G        
EDMASK= ****** G         FLTBUF  000010R      010 FLTPNT  000000R      005 MK.SYM= 000001           X40   = 000000          
ED.FPT= ****** G         FLTDOT  000002R      010 FLTSAV  000020R      010 MODE  = ****** G         $TIMDF= 000007          
ERN10 = ****** G         FLTEXP  000004R      010 FLTSGN  000000R      010 PDPV45= 000000           ..Z   = ****** G        
ERN11 = ****** G         FLTGAD  001144R      002 FLTWDC  000000R      012 RSX11D= 000000           ..ZBUF= ****** G        
ERN9  = ****** G         FLTGEX  001040R      002 FLT2    000002RG     002 SAVREG= ****** G        
ERRBTS= ****** G         FLTGLS  001204R      002 FLT4    000000RG     002 SDEBUG= ****** G        
ERRREF= ****** G         FLTGRS  001166R      002 FP.1    000006R      002 SETNB = ****** G        
ERR.A = ****** G         FLTGSV  001220R      002 FP.2    000074R      002 SPACE = 000040          


Program sections

. ABS.  000000    000   (RW,I,GBL,ABS,OVR,NOSAV)
        000000    001   (RW,I,LCL,REL,CON,NOSAV)
.TEXT   001232    002   (RO,I,GBL,REL,CON,NOSAV)
.DATA   000000    003   (RW,D,GBL,REL,CON,NOSAV)
.BSS    000000    004   (RW,D,GBL,REL,CON,NOSAV)
DPURE   000004    005   (RW,D,GBL,REL,CON,NOSAV)
MIXED   000000    006   (RW,I,GBL,REL,CON,NOSAV)
ERRMES  000000    007   (RW,D,GBL,REL,CON,NOSAV)
IMPURE  000030    010   (RW,D,GBL,REL,CON,NOSAV)
IMPPAS  000000    011   (RW,D,GBL,REL,CON,NOSAV)
IMPLIN  000002    012   (RW,D,GBL,REL,CON,NOSAV)
SWTSEC  000000    013   (RW,D,GBL,REL,CON,NOSAV)
CNDSEC  000000    014   (RW,D,GBL,REL,CON,NOSAV)
CRFSEC  000000    015   (RW,D,GBL,REL,CON,NOSAV)
EDTSEC  000006    016   (RW,D,GBL,REL,CON,NOSAV)
LCTSEC  000000    017   (RW,D,GBL,REL,CON,NOSAV)
PSASEC  000000    020   (RW,D,GBL,REL,CON,NOSAV)
PSTSEC  000000    021   (RW,D,GBL,REL,CON,NOSAV)
ROLBAS  000000    022   (RW,D,GBL,REL,CON,NOSAV)
ROLSIZ  000000    023   (RW,D,GBL,REL,CON,NOSAV)
ROLTOP  000000    024   (RW,D,GBL,REL,CON,NOSAV)
XPCOR   000000    025   (RW,D,GBL,REL,CON,NOSAV)
